{
  "name": "Market Intelligence Orchestrator V2 - Registry Based",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 */3 * * *"
            }
          ]
        }
      },
      "id": "scheduled-intelligence-collection",
      "name": "Every 3 Hours Intelligence Collection",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "/market-intelligence",
        "responseMode": "onReceived"
      },
      "id": "manual-intelligence-trigger",
      "name": "Manual Intelligence Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "operation": "select",
        "table": "DataSource",
        "returnAll": false,
        "limit": 10,
        "where": {
          "conditions": [
            {
              "field": "isActive",
              "value": true
            },
            {
              "field": "category",
              "operation": "in",
              "value": "social,reviews,news"
            },
            {
              "field": "insightRelevance",
              "operation": "gte",
              "value": 6
            }
          ]
        },
        "sort": {
          "sortRules": [
            {
              "field": "overallScore",
              "order": "DESC"
            }
          ]
        }
      },
      "id": "fetch-sentiment-sources",
      "name": "Fetch Active Sentiment Sources",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 400],
      "credentials": {
        "postgres": {
          "id": "hyperformant-postgres-credentials",
          "name": "Hyperformant Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "select",
        "table": "Entity",
        "returnAll": false,
        "limit": 20,
        "where": {
          "conditions": [
            {
              "field": "type",
              "value": "COMPANY"
            }
          ]
        },
        "additionalFields": {
          "rawQuery": true,
          "query": "SELECT e.*, COUNT(mi.id) as insight_count, MAX(mi.extractedAt) as last_insight FROM Entity e LEFT JOIN MarketInsight mi ON e.id = mi.entityId WHERE e.type = 'COMPANY' GROUP BY e.id ORDER BY last_insight ASC NULLS FIRST LIMIT 20"
        }
      },
      "id": "fetch-priority-companies",
      "name": "Fetch Priority Companies",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 200],
      "credentials": {
        "postgres": {
          "id": "hyperformant-postgres-credentials",
          "name": "Hyperformant Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare intelligent collection strategy using DataSource registry\nconst sources = $node['Fetch Active Sentiment Sources'].json;\nconst companies = $node['Fetch Priority Companies'].json;\n\n// Group sources by their capabilities\nconst sourceMap = {\n  reddit: sources.find(s => s.name.includes('reddit')),\n  twitter: sources.find(s => s.name.includes('twitter')),\n  g2: sources.find(s => s.name.includes('g2')),\n  hackernews: sources.find(s => s.name.includes('hackernews')),\n  producthunt: sources.find(s => s.name.includes('producthunt')),\n  googlenews: sources.find(s => s.name.includes('google_news')),\n  github: sources.find(s => s.name.includes('github'))\n};\n\n// Create collection tasks based on available sources and company priorities\nconst collectionTasks = [];\n\ncompanies.forEach(company => {\n  const companyName = company.name.replace(/[^a-zA-Z0-9\\s]/g, '');\n  const domain = (company.domain || '').replace('.com', '').replace('.io', '').replace('.co', '');\n  \n  const task = {\n    company: {\n      id: company.id,\n      name: company.name,\n      domain: company.domain,\n      industry: company.industry\n    },\n    queries: {},\n    activeSources: [],\n    priority: company.insight_count ? 'normal' : 'high'\n  };\n  \n  // Build queries for each active source\n  Object.entries(sourceMap).forEach(([key, source]) => {\n    if (source && source.isActive) {\n      task.activeSources.push({\n        id: source.id,\n        name: source.name,\n        endpoint: source.endpoint,\n        insightCapabilities: source.insightCapabilities || []\n      });\n      \n      // Create appropriate query based on source type\n      switch(key) {\n        case 'reddit':\n          task.queries.reddit = `\"${companyName}\" OR \"${domain}\" subreddit:SaaS OR subreddit:startups`;\n          break;\n        case 'twitter':\n          task.queries.twitter = `\"${companyName}\" OR \"${domain}\" -is:retweet lang:en`;\n          break;\n        case 'g2':\n          task.queries.g2 = companyName;\n          break;\n        case 'hackernews':\n          task.queries.hackernews = `\"${companyName}\" OR \"${domain}\"`;\n          break;\n        case 'producthunt':\n          task.queries.producthunt = companyName.toLowerCase();\n          break;\n        case 'googlenews':\n          task.queries.googlenews = `${companyName} software`;\n          break;\n        case 'github':\n          task.queries.github = `org:${domain} OR ${companyName}`;\n          break;\n      }\n    }\n  });\n  \n  if (task.activeSources.length > 0) {\n    collectionTasks.push(task);\n  }\n});\n\nreturn {\n  collectionTasks: collectionTasks,\n  totalCompanies: companies.length,\n  activeSources: sources.length,\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "prepare-collection-strategy",
      "name": "Prepare Collection Strategy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Dynamic data collection based on active sources\nconst strategy = $json;\nconst tasks = strategy.collectionTasks;\nconst results = [];\n\nfor (const task of tasks) {\n  const companyResults = {\n    company: task.company,\n    collectedData: [],\n    sources: task.activeSources\n  };\n  \n  // Simulate collection from each source\n  // In production, this would make actual API calls based on source configuration\n  task.activeSources.forEach(source => {\n    const sourceData = {\n      sourceId: source.id,\n      sourceName: source.name,\n      timestamp: new Date().toISOString(),\n      dataPoints: []\n    };\n    \n    // Mock data collection (replace with actual API calls)\n    if (source.name.includes('reddit')) {\n      sourceData.dataPoints = [\n        { type: 'post', sentiment: 'mixed', content: 'Discussion about ' + task.company.name },\n        { type: 'comment', sentiment: 'positive', content: 'Great product from ' + task.company.name }\n      ];\n    } else if (source.name.includes('twitter')) {\n      sourceData.dataPoints = [\n        { type: 'tweet', sentiment: 'positive', content: 'Tweet about ' + task.company.name },\n        { type: 'mention', sentiment: 'neutral', content: 'Mention of ' + task.company.name }\n      ];\n    } else if (source.name.includes('news')) {\n      sourceData.dataPoints = [\n        { type: 'article', sentiment: 'positive', content: 'News article about ' + task.company.name }\n      ];\n    }\n    \n    companyResults.collectedData.push(sourceData);\n  });\n  \n  results.push(companyResults);\n}\n\nreturn results.map(r => ({ json: r }));"
      },
      "id": "collect-from-sources",
      "name": "Collect From Sources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "model": "claude-3-haiku-20240307",
        "messages": {
          "messageType": "defineBelow",
          "messages": [
            {
              "role": "system",
              "content": "You are a market intelligence analyst extracting actionable insights from multi-source data. Focus on sentiment, vulnerabilities, opportunities, and competitive signals. Do not store raw content - only extract intelligence."
            },
            {
              "role": "user",
              "content": "=Analyze this multi-source data for {{ $json.company.name }}:\n\n{{ JSON.stringify($json.collectedData) }}\n\nExtract and synthesize:\n1. Overall sentiment and trend\n2. Key pain points and vulnerabilities\n3. Market opportunities and threats\n4. Competitive positioning signals\n5. Customer migration indicators\n\nFor each insight, provide:\n- Type: opportunity, threat, trend, signal, vulnerability\n- Category: competitive, financial, technical, market, operational\n- Impact: 0-10\n- Confidence: 0-1\n- Urgency: low, medium, high, critical\n- Contributing sources\n\nReturn as JSON:\n{\n  \"marketInsights\": [\n    {\n      \"insightType\": \"string\",\n      \"category\": \"string\",\n      \"title\": \"string\",\n      \"summary\": \"string\",\n      \"impact\": 0-10,\n      \"confidence\": 0-1,\n      \"urgency\": \"string\",\n      \"contributingSources\": [],\n      \"implications\": [],\n      \"actionability\": \"string\"\n    }\n  ],\n  \"sentimentAnalysis\": {\n    \"overall\": \"positive|neutral|negative\",\n    \"score\": -1 to 1,\n    \"trend\": \"improving|stable|declining\",\n    \"confidence\": 0-1\n  },\n  \"competitiveIntelligence\": {\n    \"vulnerabilities\": [],\n    \"opportunities\": [],\n    \"threats\": []\n  }\n}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 1500
        }
      },
      "id": "extract-insights",
      "name": "Extract Market Insights",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1,
      "position": [1000, 300],
      "credentials": {
        "anthropicApi": {
          "id": "anthropic-api",
          "name": "Anthropic API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process extracted insights and prepare for storage\nconst rawInsights = JSON.parse($node['Extract Market Insights'].json.response);\nconst companyData = $json;\n\n// Calculate validity periods based on urgency\nconst getValidityPeriod = (urgency) => {\n  switch(urgency) {\n    case 'critical': return 24 * 60 * 60 * 1000; // 24 hours\n    case 'high': return 3 * 24 * 60 * 60 * 1000; // 3 days\n    case 'medium': return 7 * 24 * 60 * 60 * 1000; // 7 days\n    default: return 14 * 24 * 60 * 60 * 1000; // 14 days\n  }\n};\n\n// Prepare MarketInsight records\nconst marketInsights = (rawInsights.marketInsights || []).map(insight => ({\n  entityId: companyData.company.id,\n  insightType: insight.insightType,\n  category: insight.category,\n  title: insight.title,\n  summary: insight.summary,\n  impact: insight.impact,\n  confidence: insight.confidence,\n  urgency: insight.urgency,\n  contributingSources: insight.contributingSources || companyData.sources.map(s => s.name),\n  sourceConsensus: insight.confidence, // Use confidence as proxy for consensus\n  dataPointCount: companyData.collectedData.reduce((sum, d) => sum + d.dataPoints.length, 0),\n  implications: insight.implications || [],\n  actionability: insight.actionability,\n  extractedAt: new Date().toISOString(),\n  validUntil: new Date(Date.now() + getValidityPeriod(insight.urgency)).toISOString()\n}));\n\n// Prepare SentimentData record\nconst sentimentData = {\n  companyId: companyData.company.id,\n  source: 'aggregated_intelligence',\n  dataSourceId: companyData.sources[0]?.id, // Primary source\n  sentiment: rawInsights.sentimentAnalysis?.overall || 'neutral',\n  score: rawInsights.sentimentAnalysis?.score || 0,\n  content: `Overall sentiment: ${rawInsights.sentimentAnalysis?.overall}, Trend: ${rawInsights.sentimentAnalysis?.trend}`,\n  confidence: rawInsights.sentimentAnalysis?.confidence || 0.5\n};\n\n// Track source performance\nconst sourcePerformance = companyData.sources.map(source => ({\n  sourceId: source.id,\n  insightsGenerated: marketInsights.filter(i => \n    i.contributingSources.includes(source.name)\n  ).length,\n  dataPointsProcessed: companyData.collectedData.find(d => \n    d.sourceId === source.id\n  )?.dataPoints.length || 0\n}));\n\nreturn {\n  company: companyData.company,\n  marketInsights: marketInsights,\n  sentimentData: sentimentData,\n  sourcePerformance: sourcePerformance,\n  competitiveIntelligence: rawInsights.competitiveIntelligence\n};"
      },
      "id": "process-insights",
      "name": "Process Insights",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "MarketInsight",
        "columns": "entityId,insightType,category,title,summary,impact,confidence,urgency,contributingSources,sourceConsensus,dataPointCount,implications,actionability,extractedAt,validUntil",
        "options": {
          "onConflict": "update",
          "conflictColumns": "entityId,title"
        }
      },
      "id": "store-market-insights",
      "name": "Store Market Insights",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1400, 250],
      "credentials": {
        "postgres": {
          "id": "hyperformant-postgres-credentials",
          "name": "Hyperformant Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "SentimentData",
        "columns": "companyId,source,dataSourceId,sentiment,score,content,confidence"
      },
      "id": "store-sentiment",
      "name": "Store Sentiment",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1400, 350],
      "credentials": {
        "postgres": {
          "id": "hyperformant-postgres-credentials",
          "name": "Hyperformant Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Update DataSource metrics based on performance\nconst allPerformance = $input.all().map(i => i.json.sourcePerformance).flat();\n\n// Aggregate performance by source\nconst sourceMetrics = {};\nallPerformance.forEach(perf => {\n  if (!sourceMetrics[perf.sourceId]) {\n    sourceMetrics[perf.sourceId] = {\n      sourceId: perf.sourceId,\n      totalInsights: 0,\n      totalDataPoints: 0,\n      runs: 0\n    };\n  }\n  sourceMetrics[perf.sourceId].totalInsights += perf.insightsGenerated;\n  sourceMetrics[perf.sourceId].totalDataPoints += perf.dataPointsProcessed;\n  sourceMetrics[perf.sourceId].runs += 1;\n});\n\n// Calculate new quality scores\nconst updates = Object.values(sourceMetrics).map(metrics => {\n  const insightDensity = metrics.totalDataPoints > 0 ? \n    Math.min(10, (metrics.totalInsights / metrics.totalDataPoints) * 20) : 5;\n  \n  return {\n    id: metrics.sourceId,\n    insightDensity: insightDensity,\n    lastHealthCheck: new Date().toISOString(),\n    healthStatus: metrics.totalInsights > 0 ? 'healthy' : 'degraded'\n  };\n});\n\nreturn updates.map(update => ({ json: update }));"
      },
      "id": "calculate-source-metrics",
      "name": "Calculate Source Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 450]
    },
    {
      "parameters": {
        "operation": "update",
        "table": "DataSource",
        "updateKey": "id",
        "columns": "insightDensity,lastHealthCheck,healthStatus"
      },
      "id": "update-source-metrics",
      "name": "Update Source Metrics",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1600, 450],
      "credentials": {
        "postgres": {
          "id": "hyperformant-postgres-credentials",
          "name": "Hyperformant Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Identify vulnerabilities and M&A opportunities\nconst allInsights = $input.all();\nconst vulnerabilities = [];\nconst opportunities = [];\n\nallInsights.forEach(item => {\n  const intel = item.json.competitiveIntelligence;\n  const company = item.json.company;\n  \n  // Extract vulnerabilities\n  if (intel?.vulnerabilities?.length > 0) {\n    intel.vulnerabilities.forEach(vuln => {\n      vulnerabilities.push({\n        companyId: company.id,\n        companyName: company.name,\n        vulnerability: vuln,\n        timestamp: new Date().toISOString()\n      });\n    });\n  }\n  \n  // Extract opportunities\n  if (intel?.opportunities?.length > 0) {\n    intel.opportunities.forEach(opp => {\n      opportunities.push({\n        companyId: company.id,\n        companyName: company.name,\n        opportunity: opp,\n        timestamp: new Date().toISOString()\n      });\n    });\n  }\n});\n\n// Check for M&A signals\nconst maSignals = allInsights.filter(item => {\n  const insights = item.json.marketInsights || [];\n  return insights.some(i => \n    i.category === 'financial' && \n    (i.insightType === 'vulnerability' || i.urgency === 'critical')\n  );\n}).map(item => ({\n  companyId: item.json.company.id,\n  companyName: item.json.company.name,\n  signalStrength: 'medium',\n  indicators: item.json.marketInsights.filter(i => i.category === 'financial')\n}));\n\nreturn {\n  vulnerabilitiesFound: vulnerabilities.length,\n  opportunitiesFound: opportunities.length,\n  maSignalsDetected: maSignals.length,\n  vulnerabilities: vulnerabilities,\n  opportunities: opportunities,\n  maSignals: maSignals,\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "detect-strategic-signals",
      "name": "Detect Strategic Signals",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1600, 300]
    },
    {
      "parameters": {
        "content": "=## Market Intelligence Collection Report\n\n**Collection Time:** {{ $json.timestamp }}\n\n### Summary\n- **Vulnerabilities Detected:** {{ $json.vulnerabilitiesFound }}\n- **Opportunities Found:** {{ $json.opportunitiesFound }}\n- **M&A Signals:** {{ $json.maSignalsDetected }}\n\n### Key Vulnerabilities\n{{ JSON.stringify($json.vulnerabilities.slice(0, 5), null, 2) }}\n\n### Top Opportunities\n{{ JSON.stringify($json.opportunities.slice(0, 5), null, 2) }}\n\n### M&A Signals\n{{ JSON.stringify($json.maSignals, null, 2) }}",
        "options": {
          "contentPropertyName": "report"
        }
      },
      "id": "generate-report",
      "name": "Generate Intelligence Report",
      "type": "n8n-nodes-base.markdown",
      "typeVersion": 1,
      "position": [1800, 300]
    }
  ],
  "connections": {
    "scheduled-intelligence-collection": {
      "main": [
        [
          {
            "node": "fetch-priority-companies",
            "type": "main",
            "index": 0
          },
          {
            "node": "fetch-sentiment-sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "manual-intelligence-trigger": {
      "main": [
        [
          {
            "node": "fetch-priority-companies",
            "type": "main",
            "index": 0
          },
          {
            "node": "fetch-sentiment-sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fetch-priority-companies": {
      "main": [
        [
          {
            "node": "prepare-collection-strategy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fetch-sentiment-sources": {
      "main": [
        [
          {
            "node": "prepare-collection-strategy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare-collection-strategy": {
      "main": [
        [
          {
            "node": "collect-from-sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "collect-from-sources": {
      "main": [
        [
          {
            "node": "extract-insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "extract-insights": {
      "main": [
        [
          {
            "node": "process-insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process-insights": {
      "main": [
        [
          {
            "node": "store-market-insights",
            "type": "main",
            "index": 0
          },
          {
            "node": "store-sentiment",
            "type": "main",
            "index": 0
          },
          {
            "node": "calculate-source-metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "calculate-source-metrics": {
      "main": [
        [
          {
            "node": "update-source-metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "store-market-insights": {
      "main": [
        [
          {
            "node": "detect-strategic-signals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "detect-strategic-signals": {
      "main": [
        [
          {
            "node": "generate-report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}