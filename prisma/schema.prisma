datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt

  email                     String?         @unique
  username                  String?         @unique
  name                      String?
  image                     String?
  emailVerified             DateTime?
  isAdmin                   Boolean         @default(false)
  
  // Authentication fields
  password                  String?
  verificationCode          String?
  verificationExpiry        DateTime?
  resetToken                String?
  resetTokenExpiry          DateTime?

  paymentProcessorUserId    String?         @unique
  lemonSqueezyCustomerPortalUrl String?     // You can delete this if you're not using Lemon Squeezy as your payments processor.
  subscriptionStatus        String?         // 'active', 'cancel_at_period_end', 'past_due', 'deleted'
  subscriptionPlan          String?         // 'hobby', 'pro'
  datePaid                  DateTime?
  credits                   Int             @default(3)

  // NextAuth.js relations
  accounts                  Account[]
  sessions                  Session[]

  gptResponses              GptResponse[]
  contactFormMessages       ContactFormMessage[]
  tasks                     Task[]
  files                     File[]
  entities                  Entity[]                  @relation("EntityCreatedBy")
  reports                   Report[]
  entityMembers             EntityMember[]
  entityAccessRequests      EntityAccessRequest[]
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model GptResponse {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  content                   String
}

model Task {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  description               String
  time                      String          @default("1")
  isDone                    Boolean         @default(false)
}

model File {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  name                      String
  type                      String
  key                       String
  uploadUrl                 String
}

model DailyStats {
  id                               Int             @id @default(autoincrement())
  date                             DateTime        @default(now()) @unique

  totalViews                       Int             @default(0)
  prevDayViewsChangePercent        String          @default("0")
  userCount                        Int             @default(0)
  paidUserCount                    Int             @default(0)
  userDelta                        Int             @default(0)
  paidUserDelta                    Int             @default(0)
  totalRevenue                     Float           @default(0)
  totalProfit                      Float           @default(0)

  sources                          PageViewSource[]
}

model PageViewSource {
  @@id([date, name])
  name                     String
  date                     DateTime        @default(now())

  dailyStats               DailyStats?     @relation(fields: [dailyStatsId], references: [id])
  dailyStatsId             Int?

  visitors                 Int
}

model Logs {
  id                       Int             @id @default(autoincrement())
  createdAt                DateTime        @default(now())

  message                  String
  level                    String
}

model ContactFormMessage {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  content                   String
  isRead                    Boolean         @default(false)
  repliedAt                 DateTime?
}

// Hyperformant-specific models

// Entity Members - Many-to-many relationship with roles (replaces CompanyMember)
model EntityMember {
  id        String      @id @default(uuid()) @db.Uuid
  role      EntityRole  @default(VIEWER)
  joinedAt  DateTime    @default(now())
  
  // Relations
  entity    Entity      @relation(fields: [entityId], references: [id], onDelete: Cascade)
  entityId  String      @db.Uuid
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  
  @@unique([entityId, userId])
  @@map("entity_members")
}

// Entity Access Requests (replaces CompanyAccessRequest)
model EntityAccessRequest {
  id            String        @id @default(uuid()) @db.Uuid
  status        RequestStatus @default(PENDING)
  message       String?       // Optional message from requester
  requestedRole EntityRole    @default(VIEWER)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  // Relations
  entity        Entity        @relation(fields: [entityId], references: [id], onDelete: Cascade)
  entityId      String        @db.Uuid
  requester     User          @relation(fields: [requesterId], references: [id], onDelete: Cascade)
  requesterId   String
  
  @@unique([entityId, requesterId])
  @@map("entity_access_requests")
}

// Market Forces Reports
model Report {
  id          String      @id @default(uuid())
  title       String
  type        ReportType
  status      ReportStatus @default(PENDING)
  content     String?
  filePath    String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  entity    Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  entityId  String @db.Uuid
  createdBy User   @relation(fields: [userId], references: [id])
  userId    String

  @@map("reports")
}

// Market Intelligence Data - Stores insights, not raw content
model SentimentData {
  id           String      @id @default(uuid())
  companyId    String
  source       String      // reddit, twitter, g2, hackernews
  dataSourceId String?     @db.Uuid // Reference to DataSource registry
  dataSource   DataSource? @relation(fields: [dataSourceId], references: [id])
  sentiment    String      // positive, negative, neutral
  score        Float       // Sentiment score
  content      String      // AI-extracted insight summary, not raw content
  url          String?     // Reference URL if needed
  confidence   Float?      // AI confidence in this insight
  createdAt    DateTime    @default(now())

  @@index([companyId, source])
  @@index([dataSourceId])
  @@map("sentiment_data")
}

// Market Insights - Aggregated intelligence from multiple sources
model MarketInsight {
  id              String   @id @default(uuid()) @db.Uuid
  entityId        String   @db.Uuid
  entity          Entity   @relation(fields: [entityId], references: [id], onDelete: Cascade)
  
  // Insight classification
  insightType     String   // opportunity, threat, trend, signal, vulnerability
  category        String   // competitive, financial, technical, market, operational
  
  // Impact and confidence metrics
  impact          Float    // 0-10 impact score
  confidence      Float    // 0-1 confidence level
  urgency         String   // low, medium, high, critical
  
  // Source attribution
  contributingSources String[] // Array of DataSource names that contributed
  sourceConsensus     Float?   // How much sources agree (0-1)
  dataPointCount      Int      @default(1) // Number of data points supporting this
  
  // The insight itself (processed intelligence, not raw data)
  title           String   // Brief insight title
  summary         String   @db.Text // AI-generated insight summary
  actionability   String?  // recommended action
  implications    String[] // Business implications
  
  // Temporal aspects
  extractedAt     DateTime @default(now())
  validUntil      DateTime // When this insight expires
  occurredAt      DateTime? // When the event/trend started
  
  // Quality tracking
  wasActionable   Boolean? // Was this insight useful (feedback)
  ledToAction     String?  // What action was taken based on this
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([entityId, insightType])
  @@index([category, urgency])
  @@index([validUntil])
  @@index([extractedAt])
  @@map("market_insights")
}

// Daily Business Metrics
model DailyMetrics {
  id                  String   @id @default(uuid())
  date                DateTime @unique
  prospectCount       Int      @default(0)
  replyRate           Float    @default(0)
  previewConversions  Int      @default(0)
  fullReportSales     Int      @default(0)
  consultingConversions Int    @default(0)
  revenue             Float    @default(0)
  createdAt           DateTime @default(now())

  @@map("daily_metrics")
}

// Apollo.io Integration Tables
model ApolloSmartList {
  id          String   @id @default(uuid())
  apolloId    String   @unique
  name        String
  description String?
  filters     Json     // Apollo.io filter configuration
  prospectCount Int    @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("apollo_smart_lists")
}

model ApolloSequence {
  id              String   @id @default(uuid())
  apolloId        String   @unique
  name            String
  description     String?
  steps           Json     // Sequence step configuration
  isActive        Boolean  @default(true)
  replyRate       Float    @default(0)
  openRate        Float    @default(0)
  clickRate       Float    @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("apollo_sequences")
}

model ProspectApolloSync {
  id                String   @id @default(uuid())
  apolloContactId   String   @unique
  email             String
  firstName         String?
  lastName          String?
  company           String?
  title             String?
  linkedinUrl       String?
  status            String   // contacted, replied, interested, converted
  lastSyncAt        DateTime @default(now())
  createdAt         DateTime @default(now())

  @@map("prospect_apollo_sync")
}

model ApolloWebhookEvent {
  id        String   @id @default(uuid())
  eventType String   // contact.created, sequence.replied, etc.
  payload   Json
  processed Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("apollo_webhook_events")
}

// ========================= Competitive Intelligence Models =========================

// Reference Tables
model Industry {
  id         String          @id @default(uuid()) @db.Uuid
  name       String
  code       String?         @unique
  segments   MarketSegment[]
  entities   Entity[]
  contextValues ContextValue[]
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  @@index([name])
}

model MarketSegment {
  id          String    @id @default(uuid()) @db.Uuid
  name        String
  industryId  String    @db.Uuid
  industry    Industry  @relation(fields: [industryId], references: [id], onDelete: Cascade)
  entities    Entity[]
  contextValues ContextValue[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([name, industryId])
  @@index([industryId])
}

// Core: Entity (Consolidated Company + Entity model)
model Entity {
  id               String         @id @default(uuid()) @db.Uuid
  type             EntityType     @default(COMPANY)
  name             String
  domain           String?        @unique
  ticker           String?
  foundedAt        DateTime?
  hqCountry        String?
  hqRegion         String?
  
  // Company-specific fields
  employees        Int?
  revenue          String?
  description      String?
  
  // Competitive intelligence fields
  isUserCompany    Boolean        @default(false)
  externalIds      Json?

  industryId       String?        @db.Uuid
  industry         Industry?      @relation(fields: [industryId], references: [id], onDelete: SetNull)

  marketSegmentId  String?        @db.Uuid
  marketSegment    MarketSegment? @relation(fields: [marketSegmentId], references: [id], onDelete: SetNull)

  // User management relations (for company entities)
  createdBy        User?          @relation("EntityCreatedBy", fields: [createdByUserId], references: [id])
  createdByUserId  String?
  members          EntityMember[]
  accessRequests   EntityAccessRequest[]
  reports          Report[]

  // Competitive intelligence relations
  metrics          MetricPoint[]
  indices          IndexValue[]
  impacts          SignalImpact[]
  outgoing         Connection[]   @relation("Connection_source")
  incoming         Connection[]   @relation("Connection_target")
  marketInsights   MarketInsight[]

  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([type])
  @@index([name])
  @@index([domain])
  @@index([industryId])
  @@index([marketSegmentId])
  @@index([isUserCompany])
}

// Signals (events)
model Signal {
  id                 String          @id @default(uuid()) @db.Uuid
  timestamp          DateTime
  source             String
  category           SignalCategory
  type               SignalType
  magnitude          Float           // 0..1
  sentimentScore     Float?          // -1..1
  sentimentLabel     SentimentLabel?
  summary            String?
  details            Json?
  decayHalfLifeDays  Int?            // for visualization decay
  tags               String[]        @db.Text

  impacts            SignalImpact[]
  connectionEvents   ConnectionEvent[]

  createdAt          DateTime        @default(now())

  @@index([timestamp])
  @@index([category, type])
  @@index([magnitude])
}

model SignalImpact {
  // Join: which entities are affected by a signal and how
  signalId  String      @db.Uuid
  entityId  String      @db.Uuid
  role      ImpactRole
  weight    Float       // 0..1: contribution/importance for this entity

  signal    Signal      @relation(fields: [signalId], references: [id], onDelete: Cascade)
  entity    Entity      @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@id([signalId, entityId, role])
  @@index([entityId])
  @@index([role])
}

// Connections (relationships)
model Connection {
  id              String         @id @default(uuid()) @db.Uuid
  sourceEntityId  String         @db.Uuid
  targetEntityId  String         @db.Uuid
  type            ConnectionType
  strength        Float?         // 0..1
  sentimentScore  Float?         // -1..1
  since           DateTime
  until           DateTime?
  metadata        Json?

  source          Entity         @relation("Connection_source", fields: [sourceEntityId], references: [id], onDelete: Cascade)
  target          Entity         @relation("Connection_target", fields: [targetEntityId], references: [id], onDelete: Cascade)

  events          ConnectionEvent[]

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([sourceEntityId])
  @@index([targetEntityId])
  @@index([type])
  @@unique([sourceEntityId, targetEntityId, type, since])
}

model ConnectionEvent {
  // Optional mapping between a Signal and a Connection it created/updated
  id            String     @id @default(uuid()) @db.Uuid
  connectionId  String     @db.Uuid
  signalId      String     @db.Uuid

  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  signal        Signal     @relation(fields: [signalId], references: [id], onDelete: Cascade)

  createdAt     DateTime   @default(now())

  @@unique([connectionId, signalId])
  @@index([signalId])
}

// Performance Metrics (time-series)
model MetricDefinition {
  id          String      @id @default(uuid()) @db.Uuid
  key         String      @unique
  kind        MetricKind
  unit        String?
  description String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  points      MetricPoint[]
}

model MetricPoint {
  id                 String           @id @default(uuid()) @db.Uuid
  entityId           String           @db.Uuid
  metricDefinitionId String           @db.Uuid
  timestamp          DateTime
  window             TimeWindow       @default(DAY)
  value              Float
  source             String?
  metadata           Json?

  entity             Entity           @relation(fields: [entityId], references: [id], onDelete: Cascade)
  metricDefinition   MetricDefinition @relation(fields: [metricDefinitionId], references: [id], onDelete: Cascade)

  createdAt          DateTime         @default(now())

  @@unique([entityId, metricDefinitionId, timestamp, window])
  @@index([entityId, timestamp])
  @@index([metricDefinitionId, timestamp])
}

// Composite Indices
model IndexDefinition {
  id          String    @id @default(uuid()) @db.Uuid
  key         String    @unique
  name        String
  description String?
  formula     Json?     // freeform expression/config used by your pipeline

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  values      IndexValue[]
}

model IndexValue {
  id               String          @id @default(uuid()) @db.Uuid
  entityId         String          @db.Uuid
  indexDefinitionId String         @db.Uuid
  asOf             DateTime
  value            Float           // raw score
  normalized       Float?          // 0..1 for visualization

  entity           Entity          @relation(fields: [entityId], references: [id], onDelete: Cascade)
  indexDefinition  IndexDefinition @relation(fields: [indexDefinitionId], references: [id], onDelete: Cascade)

  createdAt        DateTime        @default(now())

  @@unique([entityId, indexDefinitionId, asOf])
  @@index([entityId, asOf])
  @@index([indexDefinitionId, asOf])
}

// Environmental Context
model ContextDimension {
  id          String    @id @default(uuid()) @db.Uuid
  key         String    @unique
  name        String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  values      ContextValue[]
}

model ContextValue {
  id                 String           @id @default(uuid()) @db.Uuid
  contextDimensionId String           @db.Uuid
  industryId         String?          @db.Uuid
  marketSegmentId    String?          @db.Uuid
  region             String?
  asOf               DateTime
  value              Float
  source             String?
  metadata           Json?

  dimension          ContextDimension @relation(fields: [contextDimensionId], references: [id], onDelete: Cascade)
  industry           Industry?        @relation(fields: [industryId], references: [id], onDelete: SetNull)
  marketSegment      MarketSegment?   @relation(fields: [marketSegmentId], references: [id], onDelete: SetNull)

  createdAt          DateTime         @default(now())

  @@index([contextDimensionId, asOf])
  @@index([industryId, asOf])
  @@index([marketSegmentId, asOf])
  @@index([region, asOf])
}

// Data Sources - Combined model for all source types (manual, discovered, API, etc.)
model DataSource {
  id                String          @id @default(uuid()) @db.Uuid
  name              String          @unique
  displayName       String?         // Human-friendly name
  type              DataSourceType
  category          String          // business, technical, social, financial, reviews
  
  // Connection Configuration
  endpoint          String?         // Base API endpoint or scraper URL
  authType          String?         // oauth2, bearer, apikey, basic, none
  credRef           String?         // Reference to credentials in env/secrets
  headers           Json?           // Custom headers needed
  queryParams       Json?           // Default query parameters
  
  // Rate Limiting & Costs
  rateLimitPerMin   Int?            // API rate limit per minute
  rateLimitPerDay   Int?            // Daily rate limit
  costPerRequest    Float           @default(0) // Cost in USD per API call
  monthlyCost       Float           @default(0) // Fixed monthly cost if subscription
  tier              String          @default("free") // free, paid, enterprise
  
  // Data Coverage & Capabilities
  coverageTypes     String[]        // companies, products, reviews, funding, news, sentiment, jobs
  dataPoints        String[]        // Specific data fields available
  geographicScope   String[]        // us, uk, eu, asia, global
  languages         String[]        // en, es, fr, de, etc.
  updateFrequency   String?         // realtime, hourly, daily, weekly, monthly
  historicalData    Boolean         @default(false) // Can fetch historical data
  
  // Insight Quality Metrics (0-10 scale, updated by monitoring)
  dataFreshness     Float           @default(5) // How recent is the data
  dataCoverage      Float           @default(5) // Breadth of companies/topics covered
  dataAccuracy      Float           @default(5) // Accuracy based on validation
  dataRelevance     Float           @default(5) // Alignment with target segments
  reliability       Float           @default(5) // Uptime and consistency
  
  // Insight-specific quality metrics
  insightDensity    Float           @default(5) // Insights per data point (efficiency)
  insightRelevance  Float           @default(5) // How relevant are the insights
  insightActionability Float        @default(5) // How actionable are the insights
  insightAccuracy   Float           @default(5) // Historical accuracy of predictions
  falsePositiveRate Float?          // Rate of incorrect insights
  truePositiveRate  Float?          // Rate of correct insights
  
  overallScore      Float           @default(5) // Weighted average score
  insightCapabilities String[]      // Types: sentiment, funding, competitive, technical, market
  
  // Operational Status
  isActive          Boolean         @default(true)
  isAutoDiscovered  Boolean         @default(false) // Found by discovery agent
  healthStatus      String          @default("unknown") // healthy, degraded, failing, unknown
  lastHealthCheck   DateTime?
  consecutiveFailures Int           @default(0)
  successRate       Float?          // Percentage of successful runs
  avgResponseTime   Int?            // Average response time in ms
  
  // Discovery & Testing
  discoveredAt      DateTime        @default(now())
  discoveryMethod   String?         // api_search, documentation, ai_suggestion, manual
  sourceUrl         String?         // Documentation or website URL
  testEndpoint      String?         // Endpoint to test availability
  lastTested        DateTime?
  testResults       Json?           // Latest test results
  
  // Scheduling & Priority
  collectionSchedule String?        // Cron expression for scheduled collection
  priority          Int             @default(5) // 1-10, higher is more important
  adaptiveScheduling Boolean        @default(false) // Adjust schedule based on data volatility
  
  // Additional Configuration
  transformScript   String?         @db.Text // JavaScript/Python to transform data
  validationRules   Json?           // Rules to validate incoming data
  enrichmentConfig  Json?           // Config for enriching data with other sources
  metadata          Json?           // Any additional source-specific config
  
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  runs              IngestionRun[]
  evaluations       SourceEvaluation[]
  sentimentData     SentimentData[]
  credential        DataSourceCredential?
  
  @@index([type, category])
  @@index([tier, isActive])
  @@index([overallScore])
  @@index([healthStatus, isActive])
  @@index([priority, isActive])
}

model IngestionRun {
  id           String     @id @default(uuid()) @db.Uuid
  dataSourceId String     @db.Uuid
  status       RunStatus  @default(PENDING)
  startedAt    DateTime   @default(now())
  finishedAt   DateTime?
  itemsIn      Int? 
  itemsOut     Int?
  error        String?
  metadata     Json?

  dataSource   DataSource @relation(fields: [dataSourceId], references: [id], onDelete: Cascade)

  @@index([dataSourceId, startedAt])
}

// Source Evaluation - Track quality assessments of data sources
model SourceEvaluation {
  id              String      @id @default(uuid()) @db.Uuid
  dataSourceId    String      @db.Uuid
  dataSource      DataSource  @relation(fields: [dataSourceId], references: [id], onDelete: Cascade)
  
  // Evaluation Metrics
  sampleSize      Int         // Number of data points evaluated
  accuracyScore   Float?      // 0-10: Data accuracy compared to known truth
  freshnessScore  Float?      // 0-10: How current is the data
  coverageScore   Float?      // 0-10: Breadth of coverage
  relevanceScore  Float?      // 0-10: Relevance to our use case
  
  // Test Results
  testQueries     String[]    // Test queries/companies used
  successCount    Int         // Successful test queries
  failureCount    Int         // Failed test queries
  
  // Data Quality Issues
  missingFields   String[]    // Important fields that are missing
  qualityIssues   String[]    // Identified data quality problems
  
  // Recommendation
  recommendation  String      // approve, reject, needs_review
  evaluatorNotes  String?     @db.Text
  
  // Performance Metrics
  avgLatency      Int?        // Average response time in ms
  errorRate       Float?      // Percentage of errors
  
  evaluatedAt     DateTime    @default(now())
  evaluatedBy     String?     // agent, manual, automated
  
  @@index([dataSourceId, evaluatedAt])
  @@index([recommendation])
}

// Secure credential storage for data sources
model DataSourceCredential {
  id            String      @id @default(uuid()) @db.Uuid
  dataSourceId  String      @unique @db.Uuid
  dataSource    DataSource  @relation(fields: [dataSourceId], references: [id], onDelete: Cascade)
  
  // Credential metadata
  authType      String      // oauth2, bearer, apikey, basic, custom
  isActive      Boolean     @default(true)
  
  // Encrypted credential data
  encryptedData String      @db.Text // JSON with encrypted keys/tokens
  
  // Management
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  expiresAt     DateTime?   // For tokens that expire
  lastUsed      DateTime?
  usageCount    Int         @default(0)
  
  @@index([dataSourceId])
  @@index([isActive, expiresAt])
  @@map("data_source_credentials")
}

// AI Provider Management System

// AI Provider registry
model AIProvider {
  id          String    @id @default(uuid()) @db.Uuid
  name        String    @unique // openai, anthropic, google, cohere, etc.
  displayName String    // "OpenAI", "Anthropic Claude", etc.
  
  // Provider configuration
  baseUrl     String    // API base URL
  authType    String    // bearer, apikey, oauth2
  
  // Capabilities
  capabilities String[] // text, chat, embeddings, vision, code, reasoning
  
  // Status and health
  isActive    Boolean   @default(true)
  healthStatus String   @default("unknown") // healthy, degraded, failing
  lastHealthCheck DateTime?
  
  // Metadata
  website     String?
  documentation String?
  pricingUrl  String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  models      AIModel[]
  credential  AIProviderCredential?
  
  @@index([name, isActive])
  @@index([healthStatus])
  @@map("ai_providers")
}

// AI Model registry  
model AIModel {
  id          String     @id @default(uuid()) @db.Uuid
  providerId  String     @db.Uuid
  provider    AIProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  // Model identification
  modelId     String     // gpt-4o, claude-3-sonnet, etc.
  name        String     // Human readable name
  version     String?    // Model version if applicable
  
  // Model capabilities
  type        String     // chat, completion, embedding, vision
  capabilities String[]  // reasoning, coding, analysis, creative
  
  // Technical specs
  contextWindow Int?     // Token context window
  maxOutput    Int?      // Max output tokens
  supportsStreaming Boolean @default(false)
  supportsVision Boolean @default(false)
  supportsFunctions Boolean @default(false)
  
  // Cost and performance
  costPer1kInput  Float? // Cost per 1k input tokens
  costPer1kOutput Float? // Cost per 1k output tokens
  avgLatencyMs    Int?   // Average response time
  
  // Quality metrics (updated by usage)
  qualityScore    Float  @default(5) // 0-10 based on performance
  reliability     Float  @default(5) // 0-10 based on uptime
  
  // Configuration
  defaultParams   Json?  // Default parameters for this model
  recommendedFor  String[] // use cases: analysis, creative, coding, etc.
  
  // Status
  isActive        Boolean @default(true)
  isDeprecated    Boolean @default(false)
  deprecationDate DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  usageStats      AIModelUsage[]
  
  @@unique([providerId, modelId])
  @@index([providerId, isActive])
  @@index([type, isActive])
  @@index([qualityScore])
  @@map("ai_models")
}

// AI Provider credentials (encrypted)
model AIProviderCredential {
  id           String     @id @default(uuid()) @db.Uuid
  providerId   String     @unique @db.Uuid
  provider     AIProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  // Encrypted credential data
  encryptedData String    @db.Text // JSON with API keys, tokens
  
  // Management
  isActive      Boolean   @default(true)
  expiresAt     DateTime?
  lastUsed      DateTime?
  usageCount    Int       @default(0)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([providerId])
  @@index([isActive, expiresAt])
  @@map("ai_provider_credentials")
}

// Track AI model usage and performance
model AIModelUsage {
  id              String   @id @default(uuid()) @db.Uuid
  modelId         String   @db.Uuid
  model           AIModel  @relation(fields: [modelId], references: [id], onDelete: Cascade)
  
  // Usage metrics
  date            DateTime @default(now())
  requestCount    Int      @default(0)
  successCount    Int      @default(0)
  errorCount      Int      @default(0)
  
  // Performance metrics
  totalTokensUsed Int      @default(0)
  avgLatencyMs    Int?
  avgQualityScore Float?
  
  // Cost tracking
  totalCost       Float    @default(0)
  
  @@unique([modelId, date])
  @@index([modelId, date])
  @@map("ai_model_usage")
}

// Enums
enum ReportType {
  PREVIEW
  FULL
  CUSTOM
}

enum ReportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum EntityRole {
  ADMIN
  EDITOR
  VIEWER
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// Competitive Intelligence Enums
enum EntityType {
  COMPANY
  PRODUCT
  PERSON
  MARKET
  SEGMENT
}

enum SignalCategory {
  MARKET
  COMPETITIVE
  DEAL
  PRODUCT
  TALENT
  RISK
  ENGAGEMENT
}

enum SignalType {
  // Existing core signals
  ACQUISITION
  FUNDING_ROUND
  PARTNERSHIP
  COMPETITOR_LAUNCH
  PRICING_CHANGE
  MARKET_ENTRY
  CUSTOMER_WIN
  CUSTOMER_LOSS
  PRESS_MENTION
  SOCIAL_POST
  REVIEW
  PRODUCT_LAUNCH
  MAJOR_UPDATE
  PATENT_FILED
  EXEC_HIRE
  EXEC_DEPARTURE
  LAYOFF
  LAWSUIT
  SECURITY_BREACH
  REGULATORY_CHANGE
  TRAFFIC_SPIKE
  SEO_RANK_CHANGE
  ANALYST_FORECAST
  TREND_REPORT
  IPO
  MERGER
  CONTROVERSY
  
  // Phase 1: New high-impact signals
  TECH_STACK_CHANGE
  WEBSITE_UPDATE
  PATENT_APPLICATION
  SOCIAL_MENTION
  REDDIT_DISCUSSION
  EXEC_TWEET
  TRAFFIC_ANOMALY
  INNOVATION_SIGNAL
  EARNINGS_REPORT
  MARKET_SHARE_CHANGE
  CUSTOMER_FEEDBACK
  PRODUCT_REVIEW
  INTEGRATION_LAUNCH
  API_CHANGE
  SECURITY_UPDATE
}

enum SentimentLabel {
  NEGATIVE
  NEUTRAL
  POSITIVE
}

enum ConnectionType {
  PARTNERSHIP
  COMPETITOR
  CUSTOMER_SUPPLIER
  INVESTOR_PORTFOLIO
  OWNERSHIP
  BOARD_LINK
  JOINT_RD
  CO_PATENT
  TECH_AFFINITY
  REGULATORY
  LEGAL_DISPUTE
  SUPPLY_CHAIN
  INDUSTRY_ADJACENCY
  WEAK_COMPETITOR
}

enum MetricKind {
  FINANCIAL
  DIGITAL
  OPERATIONAL
  SENTIMENT
  INNOVATION
  // Phase 1: Extended metric categories
  SOCIAL_ENGAGEMENT
  WEB_ANALYTICS
  PATENT_ACTIVITY
  NEWS_MENTIONS
  APOLLO_METRICS
}

enum TimeWindow {
  DAY
  WEEK
  MONTH
  QUARTER
  YEAR
}

enum RunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum DataSourceType {
  API
  SCRAPER
  MANUAL
  LLM
  // Phase 1: High-impact sources
  APOLLO_CRM
  APOLLO_WEBHOOK
  FINANCIAL_API
  SOCIAL_API
  WEB_ANALYTICS
  PATENT_API
}

enum ImpactRole {
  SUBJECT
  ACTOR
  TARGET
  MENTIONED
}