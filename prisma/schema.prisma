datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt

  email                     String?         @unique
  username                  String?         @unique
  name                      String?
  image                     String?
  emailVerified             DateTime?
  isAdmin                   Boolean         @default(false)
  
  // Authentication fields
  password                  String?
  verificationCode          String?
  verificationExpiry        DateTime?
  resetToken                String?
  resetTokenExpiry          DateTime?

  paymentProcessorUserId    String?         @unique
  lemonSqueezyCustomerPortalUrl String?     // You can delete this if you're not using Lemon Squeezy as your payments processor.
  subscriptionStatus        String?         // 'active', 'cancel_at_period_end', 'past_due', 'deleted'
  subscriptionPlan          String?         // 'hobby', 'pro'
  datePaid                  DateTime?
  credits                   Int             @default(3)

  // NextAuth.js relations
  accounts                  Account[]
  sessions                  Session[]

  gptResponses              GptResponse[]
  contactFormMessages       ContactFormMessage[]
  tasks                     Task[]
  files                     File[]
  entities                  Entity[]                  @relation("EntityCreatedBy")
  reports                   Report[]
  entityMembers             EntityMember[]
  entityAccessRequests      EntityAccessRequest[]
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model GptResponse {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  content                   String
}

model Task {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  description               String
  time                      String          @default("1")
  isDone                    Boolean         @default(false)
}

model File {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  name                      String
  type                      String
  key                       String
  uploadUrl                 String
}

model DailyStats {
  id                               Int             @id @default(autoincrement())
  date                             DateTime        @default(now()) @unique

  totalViews                       Int             @default(0)
  prevDayViewsChangePercent        String          @default("0")
  userCount                        Int             @default(0)
  paidUserCount                    Int             @default(0)
  userDelta                        Int             @default(0)
  paidUserDelta                    Int             @default(0)
  totalRevenue                     Float           @default(0)
  totalProfit                      Float           @default(0)

  sources                          PageViewSource[]
}

model PageViewSource {
  @@id([date, name])
  name                     String
  date                     DateTime        @default(now())

  dailyStats               DailyStats?     @relation(fields: [dailyStatsId], references: [id])
  dailyStatsId             Int?

  visitors                 Int
}

model Logs {
  id                       Int             @id @default(autoincrement())
  createdAt                DateTime        @default(now())

  message                  String
  level                    String
}

model ContactFormMessage {
  id                        String          @id @default(uuid())
  createdAt                 DateTime        @default(now())

  user                      User            @relation(fields: [userId], references: [id])
  userId                    String

  content                   String
  isRead                    Boolean         @default(false)
  repliedAt                 DateTime?
}

// Hyperformant-specific models

// Entity Members - Many-to-many relationship with roles (replaces CompanyMember)
model EntityMember {
  id        String      @id @default(uuid()) @db.Uuid
  role      EntityRole  @default(VIEWER)
  joinedAt  DateTime    @default(now())
  
  // Relations
  entity    Entity      @relation(fields: [entityId], references: [id], onDelete: Cascade)
  entityId  String      @db.Uuid
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  
  @@unique([entityId, userId])
  @@map("entity_members")
}

// Entity Access Requests (replaces CompanyAccessRequest)
model EntityAccessRequest {
  id            String        @id @default(uuid()) @db.Uuid
  status        RequestStatus @default(PENDING)
  message       String?       // Optional message from requester
  requestedRole EntityRole    @default(VIEWER)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  // Relations
  entity        Entity        @relation(fields: [entityId], references: [id], onDelete: Cascade)
  entityId      String        @db.Uuid
  requester     User          @relation(fields: [requesterId], references: [id], onDelete: Cascade)
  requesterId   String
  
  @@unique([entityId, requesterId])
  @@map("entity_access_requests")
}

// Market Forces Reports
model Report {
  id          String      @id @default(uuid())
  title       String
  type        ReportType
  status      ReportStatus @default(PENDING)
  content     String?
  filePath    String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  entity    Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  entityId  String @db.Uuid
  createdBy User   @relation(fields: [userId], references: [id])
  userId    String

  @@map("reports")
}

// Market Intelligence Data
model SentimentData {
  id        String   @id @default(uuid())
  companyId String
  source    String   // reddit, twitter, g2, hackernews
  sentiment String   // positive, negative, neutral
  score     Float
  content   String
  url       String?
  createdAt DateTime @default(now())

  @@map("sentiment_data")
}

// Daily Business Metrics
model DailyMetrics {
  id                  String   @id @default(uuid())
  date                DateTime @unique
  prospectCount       Int      @default(0)
  replyRate           Float    @default(0)
  previewConversions  Int      @default(0)
  fullReportSales     Int      @default(0)
  consultingConversions Int    @default(0)
  revenue             Float    @default(0)
  createdAt           DateTime @default(now())

  @@map("daily_metrics")
}

// Apollo.io Integration Tables
model ApolloSmartList {
  id          String   @id @default(uuid())
  apolloId    String   @unique
  name        String
  description String?
  filters     Json     // Apollo.io filter configuration
  prospectCount Int    @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("apollo_smart_lists")
}

model ApolloSequence {
  id              String   @id @default(uuid())
  apolloId        String   @unique
  name            String
  description     String?
  steps           Json     // Sequence step configuration
  isActive        Boolean  @default(true)
  replyRate       Float    @default(0)
  openRate        Float    @default(0)
  clickRate       Float    @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("apollo_sequences")
}

model ProspectApolloSync {
  id                String   @id @default(uuid())
  apolloContactId   String   @unique
  email             String
  firstName         String?
  lastName          String?
  company           String?
  title             String?
  linkedinUrl       String?
  status            String   // contacted, replied, interested, converted
  lastSyncAt        DateTime @default(now())
  createdAt         DateTime @default(now())

  @@map("prospect_apollo_sync")
}

model ApolloWebhookEvent {
  id        String   @id @default(uuid())
  eventType String   // contact.created, sequence.replied, etc.
  payload   Json
  processed Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("apollo_webhook_events")
}

// ========================= Competitive Intelligence Models =========================

// Reference Tables
model Industry {
  id         String          @id @default(uuid()) @db.Uuid
  name       String
  code       String?         @unique
  segments   MarketSegment[]
  entities   Entity[]
  contextValues ContextValue[]
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  @@index([name])
}

model MarketSegment {
  id          String    @id @default(uuid()) @db.Uuid
  name        String
  industryId  String    @db.Uuid
  industry    Industry  @relation(fields: [industryId], references: [id], onDelete: Cascade)
  entities    Entity[]
  contextValues ContextValue[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([name, industryId])
  @@index([industryId])
}

// Core: Entity (Consolidated Company + Entity model)
model Entity {
  id               String         @id @default(uuid()) @db.Uuid
  type             EntityType     @default(COMPANY)
  name             String
  domain           String?        @unique
  ticker           String?
  foundedAt        DateTime?
  hqCountry        String?
  hqRegion         String?
  
  // Company-specific fields
  employees        Int?
  revenue          String?
  description      String?
  
  // Competitive intelligence fields
  isUserCompany    Boolean        @default(false)
  externalIds      Json?

  industryId       String?        @db.Uuid
  industry         Industry?      @relation(fields: [industryId], references: [id], onDelete: SetNull)

  marketSegmentId  String?        @db.Uuid
  marketSegment    MarketSegment? @relation(fields: [marketSegmentId], references: [id], onDelete: SetNull)

  // User management relations (for company entities)
  createdBy        User?          @relation("EntityCreatedBy", fields: [createdByUserId], references: [id])
  createdByUserId  String?
  members          EntityMember[]
  accessRequests   EntityAccessRequest[]
  reports          Report[]

  // Competitive intelligence relations
  metrics          MetricPoint[]
  indices          IndexValue[]
  impacts          SignalImpact[]
  outgoing         Connection[]   @relation("Connection_source")
  incoming         Connection[]   @relation("Connection_target")

  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([type])
  @@index([name])
  @@index([domain])
  @@index([industryId])
  @@index([marketSegmentId])
  @@index([isUserCompany])
}

// Signals (events)
model Signal {
  id                 String          @id @default(uuid()) @db.Uuid
  timestamp          DateTime
  source             String
  category           SignalCategory
  type               SignalType
  magnitude          Float           // 0..1
  sentimentScore     Float?          // -1..1
  sentimentLabel     SentimentLabel?
  summary            String?
  details            Json?
  decayHalfLifeDays  Int?            // for visualization decay
  tags               String[]        @db.Text

  impacts            SignalImpact[]
  connectionEvents   ConnectionEvent[]

  createdAt          DateTime        @default(now())

  @@index([timestamp])
  @@index([category, type])
  @@index([magnitude])
}

model SignalImpact {
  // Join: which entities are affected by a signal and how
  signalId  String      @db.Uuid
  entityId  String      @db.Uuid
  role      ImpactRole
  weight    Float       // 0..1: contribution/importance for this entity

  signal    Signal      @relation(fields: [signalId], references: [id], onDelete: Cascade)
  entity    Entity      @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@id([signalId, entityId, role])
  @@index([entityId])
  @@index([role])
}

// Connections (relationships)
model Connection {
  id              String         @id @default(uuid()) @db.Uuid
  sourceEntityId  String         @db.Uuid
  targetEntityId  String         @db.Uuid
  type            ConnectionType
  strength        Float?         // 0..1
  sentimentScore  Float?         // -1..1
  since           DateTime
  until           DateTime?
  metadata        Json?

  source          Entity         @relation("Connection_source", fields: [sourceEntityId], references: [id], onDelete: Cascade)
  target          Entity         @relation("Connection_target", fields: [targetEntityId], references: [id], onDelete: Cascade)

  events          ConnectionEvent[]

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([sourceEntityId])
  @@index([targetEntityId])
  @@index([type])
  @@unique([sourceEntityId, targetEntityId, type, since])
}

model ConnectionEvent {
  // Optional mapping between a Signal and a Connection it created/updated
  id            String     @id @default(uuid()) @db.Uuid
  connectionId  String     @db.Uuid
  signalId      String     @db.Uuid

  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  signal        Signal     @relation(fields: [signalId], references: [id], onDelete: Cascade)

  createdAt     DateTime   @default(now())

  @@unique([connectionId, signalId])
  @@index([signalId])
}

// Performance Metrics (time-series)
model MetricDefinition {
  id          String      @id @default(uuid()) @db.Uuid
  key         String      @unique
  kind        MetricKind
  unit        String?
  description String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  points      MetricPoint[]
}

model MetricPoint {
  id                 String           @id @default(uuid()) @db.Uuid
  entityId           String           @db.Uuid
  metricDefinitionId String           @db.Uuid
  timestamp          DateTime
  window             TimeWindow       @default(DAY)
  value              Float
  source             String?
  metadata           Json?

  entity             Entity           @relation(fields: [entityId], references: [id], onDelete: Cascade)
  metricDefinition   MetricDefinition @relation(fields: [metricDefinitionId], references: [id], onDelete: Cascade)

  createdAt          DateTime         @default(now())

  @@unique([entityId, metricDefinitionId, timestamp, window])
  @@index([entityId, timestamp])
  @@index([metricDefinitionId, timestamp])
}

// Composite Indices
model IndexDefinition {
  id          String    @id @default(uuid()) @db.Uuid
  key         String    @unique
  name        String
  description String?
  formula     Json?     // freeform expression/config used by your pipeline

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  values      IndexValue[]
}

model IndexValue {
  id               String          @id @default(uuid()) @db.Uuid
  entityId         String          @db.Uuid
  indexDefinitionId String         @db.Uuid
  asOf             DateTime
  value            Float           // raw score
  normalized       Float?          // 0..1 for visualization

  entity           Entity          @relation(fields: [entityId], references: [id], onDelete: Cascade)
  indexDefinition  IndexDefinition @relation(fields: [indexDefinitionId], references: [id], onDelete: Cascade)

  createdAt        DateTime        @default(now())

  @@unique([entityId, indexDefinitionId, asOf])
  @@index([entityId, asOf])
  @@index([indexDefinitionId, asOf])
}

// Environmental Context
model ContextDimension {
  id          String    @id @default(uuid()) @db.Uuid
  key         String    @unique
  name        String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  values      ContextValue[]
}

model ContextValue {
  id                 String           @id @default(uuid()) @db.Uuid
  contextDimensionId String           @db.Uuid
  industryId         String?          @db.Uuid
  marketSegmentId    String?          @db.Uuid
  region             String?
  asOf               DateTime
  value              Float
  source             String?
  metadata           Json?

  dimension          ContextDimension @relation(fields: [contextDimensionId], references: [id], onDelete: Cascade)
  industry           Industry?        @relation(fields: [industryId], references: [id], onDelete: SetNull)
  marketSegment      MarketSegment?   @relation(fields: [marketSegmentId], references: [id], onDelete: SetNull)

  createdAt          DateTime         @default(now())

  @@index([contextDimensionId, asOf])
  @@index([industryId, asOf])
  @@index([marketSegmentId, asOf])
  @@index([region, asOf])
}

// Operational / Provenance
model DataSource {
  id         String          @id @default(uuid()) @db.Uuid
  name       String
  type       DataSourceType
  credRef    String?
  trustScore Float?          // 0..1
  metadata   Json?

  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  runs       IngestionRun[]
}

model IngestionRun {
  id           String     @id @default(uuid()) @db.Uuid
  dataSourceId String     @db.Uuid
  status       RunStatus  @default(PENDING)
  startedAt    DateTime   @default(now())
  finishedAt   DateTime?
  itemsIn      Int? 
  itemsOut     Int?
  error        String?
  metadata     Json?

  dataSource   DataSource @relation(fields: [dataSourceId], references: [id], onDelete: Cascade)

  @@index([dataSourceId, startedAt])
}

// Enums
enum ReportType {
  PREVIEW
  FULL
  CUSTOM
}

enum ReportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum EntityRole {
  ADMIN
  EDITOR
  VIEWER
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// Competitive Intelligence Enums
enum EntityType {
  COMPANY
  PRODUCT
  PERSON
  MARKET
  SEGMENT
}

enum SignalCategory {
  MARKET
  COMPETITIVE
  DEAL
  PRODUCT
  TALENT
  RISK
  ENGAGEMENT
}

enum SignalType {
  // Existing core signals
  ACQUISITION
  FUNDING_ROUND
  PARTNERSHIP
  COMPETITOR_LAUNCH
  PRICING_CHANGE
  MARKET_ENTRY
  CUSTOMER_WIN
  CUSTOMER_LOSS
  PRESS_MENTION
  SOCIAL_POST
  REVIEW
  PRODUCT_LAUNCH
  MAJOR_UPDATE
  PATENT_FILED
  EXEC_HIRE
  EXEC_DEPARTURE
  LAYOFF
  LAWSUIT
  SECURITY_BREACH
  REGULATORY_CHANGE
  TRAFFIC_SPIKE
  SEO_RANK_CHANGE
  ANALYST_FORECAST
  TREND_REPORT
  IPO
  MERGER
  CONTROVERSY
  
  // Phase 1: New high-impact signals
  TECH_STACK_CHANGE
  WEBSITE_UPDATE
  PATENT_APPLICATION
  SOCIAL_MENTION
  REDDIT_DISCUSSION
  EXEC_TWEET
  TRAFFIC_ANOMALY
  INNOVATION_SIGNAL
  EARNINGS_REPORT
  MARKET_SHARE_CHANGE
  CUSTOMER_FEEDBACK
  PRODUCT_REVIEW
  INTEGRATION_LAUNCH
  API_CHANGE
  SECURITY_UPDATE
}

enum SentimentLabel {
  NEGATIVE
  NEUTRAL
  POSITIVE
}

enum ConnectionType {
  PARTNERSHIP
  COMPETITOR
  CUSTOMER_SUPPLIER
  INVESTOR_PORTFOLIO
  OWNERSHIP
  BOARD_LINK
  JOINT_RD
  CO_PATENT
  TECH_AFFINITY
  REGULATORY
  LEGAL_DISPUTE
  SUPPLY_CHAIN
  INDUSTRY_ADJACENCY
  WEAK_COMPETITOR
}

enum MetricKind {
  FINANCIAL
  DIGITAL
  OPERATIONAL
  SENTIMENT
  INNOVATION
  // Phase 1: Extended metric categories
  SOCIAL_ENGAGEMENT
  WEB_ANALYTICS
  PATENT_ACTIVITY
  NEWS_MENTIONS
  APOLLO_METRICS
}

enum TimeWindow {
  DAY
  WEEK
  MONTH
  QUARTER
  YEAR
}

enum RunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
}

enum DataSourceType {
  API
  SCRAPER
  MANUAL
  LLM
  // Phase 1: High-impact sources
  APOLLO_CRM
  APOLLO_WEBHOOK
  FINANCIAL_API
  SOCIAL_API
  WEB_ANALYTICS
  PATENT_API
}

enum ImpactRole {
  SUBJECT
  ACTOR
  TARGET
  MENTIONED
}